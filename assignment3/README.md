# CS106L Assignment 3: “创建类”核心知识点总结

这份文档总结了在完成 C++ “创建类”作业过程中，从设计到实现一个自定义类所涉及的核心知识点。整个过程是一次完整的面向对象编程（OOP）基础实践。

---

## 1. 面向对象编程基础：类与对象

- **类 (Class) vs. 对象 (Object)**: 我们深刻理解到，**类**是创建对象的“蓝图”或“模板”，而**对象**是根据这个蓝图创建出来的具体“实例”。
    - **在本次作业中的应用**: 我们定义的 `Pet` class 就是蓝图。而在 `sandbox.cpp` 中，我们通过 `Pet my_dog("Fido", ...);` 创建的 `my_dog` 就是一个具体的对象实例。

- **封装 (Encapsulation)**: 这是面向对象的核心思想之一，即将**数据（成员变量）**和**操作数据的函数（成员函数）**捆绑在一起，并对外部隐藏内部实现细节。
    - **在本次作业中的应用**: 我们将 `name`, `age` 等核心数据设为 **`private`**，防止了外部代码的随意篡改。同时，我们提供了 **`public`** 的 `getName()` 和 `setName()` 等方法，作为外部世界与对象内部状态交互的唯一、受控的通道。

---

## 2. 类的结构与分离式编译

### a. 声明与定义分离 (.h vs. .cpp)
- **核心实践**: 将类的**声明**（它有什么成员）放在头文件（`.h`）中，将成员函数的**具体实现**（它们怎么工作）放在源文件（`.cpp`）中。
- **在本次作业中的应用**: 我们严格遵循了这个模式，将 `Pet` 类的所有成员和函数原型都声明在 `class.h` 中，而将所有函数的实现代码都写在了 `class.cpp` 中。这使得代码结构非常清晰，接口和实现一目了然。

### b. 头文件保护 (Header Guards)
- **目的**: 防止同一个头文件在编译过程中被多次包含，从而避免重复定义错误。
- **在本次作业中的应用**: 我们在 `class.h` 的顶部和底部使用了 `#ifndef PET_H`, `#define PET_H` 和 `#endif`。这是编写 C++ 头文件的标准做法，也是通过 `CASTXML` 解析错误的关键步骤之一。

---

## 3. 类的核心成员：构造函数与成员函数

### a. 构造函数 (Constructors)
- **作用**: 在创建对象时被自动调用的特殊函数，主要用于初始化成员变量。
- **在本次作业中的应用**:
    1.  **默认构造函数** `Pet();`: 我们实现了一个无参数的构造函数，用于创建具有默认状态的 `Pet` 对象（例如，一个叫 "Unnamed" 的宠物）。
    2.  **自定义构造函数** `Pet(std::string name, ...);`: 我们还实现了一个接收多个参数的构造函数，用于创建具有特定初始状态的 `Pet` 对象。
    3.  **构造函数重载**: 同时提供以上两种构造函数，就是**重载 (Overloading)** 的体现。

### b. Getter 和 Setter 函数
- **作用**: 作为一种良好的编程模式，它们为访问和修改私有成员变量提供了公共接口。
- **在本次作业中的应用**: 我们通过 `getName()` (getter) 和 `setName()` (setter) 实践了这一模式，体现了封装原则。

---

## 4. `const` 正确性 (Const-Correctness)

这是本次作业简答题的核心，也是 C++ 中非常重要的一个概念。

- **`const` 成员函数**: 在函数声明和定义的末尾加上 `const` 关键字（如 `std::string getName() const;`），代表这个函数**承诺不会修改**对象的任何成员变量。它是一个“只读”操作。
- **在本次作业中的应用**: 我们将 `getName()` 和 `getAge()` 这样的 getter 函数都标记为了 `const`，因为它们只返回数据而不做任何修改。而 `setName()` 修改了 `name` 成员，所以它**不能**是 `const`。正确使用 `const` 不仅能让代码更安全、更易读，也是通过自动评分器检查的必要条件。

---

## 5. 编译与实践工作流

- **多文件编译**: 当项目被拆分成多个文件时，我们需要将所有相关的 `.cpp` 文件都传递给编译器。
    - **在本次作业中的应用**: 我们最终使用的编译命令是 `g++ -std=c++20 main.cpp class.cpp -o main`。这个经验告诉我们，必须将所有包含了**函数实现**的 `.cpp` 文件都告诉编译器，以便链接器（linker）能将它们组合成一个完整的程序。
- **实例化与测试**: 类的最终目的是被使用。
    - **在本次作业中的应用**: 我们在 `sandbox.cpp` 中通过 `Pet my_dog(...)` 成功创建了类的实例，并通过 `my_dog.getName()` 等方法调用了它的函数，这验证了我们整个类的设计是成功的。
