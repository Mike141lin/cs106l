# CS106L Assignment 5: "Treebook" 核心知识点总结

这份文档总结了在完成 `Treebook` 作业时，围绕 C++ 类的设计与实现所涉及的核心概念。本次作业是一次深入实践，重点在于当类中包含原生指针时，如何进行正确的手动内存管理和自定义类的行为。

---

## 1. 手动内存管理与“三/五法则”

本次作业的核心挑战在于 `User` 类使用了一个原生指针数组 `std::string* _friends` 来存储好友列表。这要求我们必须手动管理内存，并遵循“三/五法则” (Rule of Three/Five) 来确保类的行为正确。

### a. 析构函数 (Destructor) `~User()`
- **目的**: 防止内存泄漏。当一个 `User` 对象被销毁时（例如离开作用域），析构函数会被自动调用。
- **在本次作业中的应用**: 我们实现了 `~User()`，并在其中使用了 `delete[] _friends;` 来释放构造函数中通过 `new` 分配的内存。如果没有这一步，程序每次创建和销毁 `User` 对象时都会造成内存泄漏。

### b. 拷贝构造函数 (Copy Constructor) `User(const User& other)`
- **目的**: 实现**深拷贝 (Deep Copy)**。当用一个对象初始化另一个对象时（`User b(a);`），默认的拷贝行为是**浅拷贝 (Shallow Copy)**，即只复制指针的值，导致两个对象指向同一块内存。这会引发“重复释放”等严重错误。
- **在本次作业中的应用**: 我们通过以下步骤实现了深拷贝：
    1.  为新对象的 `_friends` 指针分配一块**全新的内存**。
    2.  通过循环，将原对象 `_friends` 数组中的每一个好友字符串，**逐个复制**到新分配的内存中。

### c. 拷贝赋值运算符 (Copy Assignment Operator) `User& operator=(const User& other)`
- **目的**: 在将一个已存在的对象赋值给另一个时（`a = b;`），同样实现**深拷贝**。
- **在本次作业中的应用**: 实现过程比拷贝构造更复杂：
    1.  **检查自我赋值**: 通过 `if (this != &other)` 来避免 `a = a;` 这种操作导致的意外错误。
    2.  **释放旧资源**: 在拷贝新数据前，必须先 `delete[] _friends;` 来释放当前对象已占有的内存。
    3.  **分配新内存并复制**: 与拷贝构造函数一样，分配新内存并逐个复制元素。
    4.  **返回 `*this`**: 返回对当前对象的引用，以支持链式赋值（`a = b = c;`）。

### d. 移动语义 (Move Semantics) `= delete`
- **目的**: 有时我们希望明确禁止某些行为。
- **在本次作业中的应用**: 根据作业要求，我们通过在 `.h` 文件中将移动构造函数和移动赋值运算符声明为 `= delete;`，明确地**禁止**了 `User` 对象的移动操作，强制所有权转移必须通过成本更高的拷贝来完成。

---

## 2. 运算符重载 (Operator Overloading)

通过重载运算符，我们可以让自定义的类表现得像内置类型一样直观。

### a. `operator<<` (友元函数 Friend Function)
- **目的**: 让 `User` 对象可以被 `std::cout` 直接打印。
- **在本次作业中的应用**: 我们将 `operator<<` 声明为 `User` 类的**友元 (friend)**，这使得这个非成员函数可以访问 `User` 的私有成员（如 `_name` 和 `_friends`），最终按要求格式 `User(name=..., friends=[...])` 输出。

### b. `operator+=` 和 `operator<` (成员函数 Member Functions)
- **目的**: 为类添加自定义的、符合逻辑的行为。
- **在本次作业中的应用**:
    * **`operator+=`**: 我们将其实现为成员函数，通过 `alice += charlie;` 达到了**互相添加好友**的对称效果。
    * **`operator<`**: 我们通过比较 `_name` 成员，为 `User` 对象定义了**小于**的规则。这不仅符合逻辑，也是让 `User` 对象能够被存入 `std::set` 等有序容器的前提。

---

## 3. 多文件项目的工作流

### a. 声明与定义分离 (`user.h` vs. `user.cpp`)
- **实践**: 我们再次实践了将类的**声明**（接口）放在头文件 `user.h` 中，将**定义**（实现）放在源文件 `user.cpp` 中的标准做法。

### b. 头文件包含 (`#include`)
- **实践教训**: 我们遇到的编译错误 `unknown type name 'User'` 和 `use of undeclared identifier 'std'` 强调了一个事实：每个独立的 `.cpp` 文件都必须包含它所需要的所有头文件。我们在 `user.cpp` 的顶部添加了 `#include "user.h"` 和 `#include <string>` 等，才解决了编译问题。

### c. 链接 (Linking)
- **实践教训**: 本次作业中反复出现的**链接器错误** (`ld: symbol(s) not found`) 让我们学到了最重要的一课：在编译多文件项目时，必须将**所有相关的 `.cpp` 源文件**都提供给编译器。
    * **正确的编译命令**: `g++ -std=c++20 main.cpp user.cpp -o main`
    * **错误的原因**: 如果只编译 `main.cpp`，链接器虽然从 `user.h` 中知道函数的存在，却找不到它们在 `user.cpp` 中的具体实现，因此报错。
